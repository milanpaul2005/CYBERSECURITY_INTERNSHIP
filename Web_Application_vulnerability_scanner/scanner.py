# ----------------------------------------------------
# üì¶ IMPORTING REQUIRED PYTHON LIBRARIES
# ----------------------------------------------------

from flask import Flask, render_template_string, request
# Flask: to create web server and handle user input/output

import requests
# requests: to send HTTP GET and POST requests to target sites

from bs4 import BeautifulSoup
# BeautifulSoup: to parse HTML and extract <form> elements

import re
# re: for regular expressions (used to detect SQL error messages)

from urllib.parse import urljoin
# urljoin: to build absolute URLs from relative paths in form actions


# ----------------------------------------------------
# üöÄ INITIALIZE FLASK APPLICATION
# ----------------------------------------------------
app = Flask(__name__)  # Create Flask app instance


# ----------------------------------------------------
# üí£ XSS & SQLi PAYLOADS FOR SCANNING
# ----------------------------------------------------
XSS_PAYLOAD = '<script>alert(1)</script>'  # Basic reflected XSS test

# List of SQLi payloads to increase detection chances
SQLI_PAYLOADS = [
    "' OR '1'='1",
    "' OR 1=1 --",
    "' OR 'a'='a",
    "'; DROP TABLE users;--",
    "' OR sleep(5)--"
]


# ----------------------------------------------------
# üåç CUSTOM HEADERS TO LOOK LIKE A REAL BROWSER
# ----------------------------------------------------
HEADERS = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)'
}


# ----------------------------------------------------
# üñºÔ∏è HTML TEMPLATE USED FOR THE WEB INTERFACE
# ----------------------------------------------------
TEMPLATE = """
<!doctype html>
<title>Web Vulnerability Scanner</title>
<h2>Web Vulnerability Scanner</h2>
<form method=post>
  <label>Target URL:</label>
  <input name=url size=50 required>
  <input type=submit value="Start Scan">
</form>

{% if results %}
  <h3>Scan Results:</h3>
  <ul>
    {% for item in results %}
      <li>
        <b>{{ item.type }}</b> found at <code>{{ item.url }}</code><br>
        Payload: <code>{{ item.payload|e }}</code><br>
        Evidence: <pre>{{ item.evidence|e }}</pre>
      </li>
    {% endfor %}
  </ul>
{% endif %}
"""


# ----------------------------------------------------
# üîç FUNCTION TO COLLECT FORMS FROM A TARGET WEBPAGE
# ----------------------------------------------------
def get_forms(url):
    forms = []  # Store extracted forms here

    try:
        res = requests.get(url, headers=HEADERS, timeout=5)  # Send GET request to URL
        soup = BeautifulSoup(res.content, "html.parser")  # Parse HTML content

        for form in soup.find_all("form"):  # Loop over each <form>
            action = form.get("action") or url  # Get form action or fallback to page URL
            method = form.get("method", "get").lower()  # Default to GET if method not specified

            # Collect input field names
            inputs = [i.get("name") for i in form.find_all("input") if i.get("name")]

            # Save form details
            forms.append({
                "action": urljoin(url, action),  # Make form action absolute URL
                "method": method,
                "inputs": inputs
            })

    except Exception as e:
        print(f"[!] Error while getting forms from {url}: {e}")

    return forms


# ----------------------------------------------------
# ‚öîÔ∏è FUNCTION TO TEST FOR XSS & SQLi VULNERABILITIES
# ----------------------------------------------------
def test_vulnerabilities(url):
    results = []  # Store vulnerability findings

    try:
        forms = get_forms(url)  # Extract forms from the target page

        for form in forms:
            # ============ XSS TESTING ============
            xss_data = {name: XSS_PAYLOAD for name in form["inputs"]}

            try:
                # Send request based on method (GET or POST)
                if form["method"] == "post":
                    res = requests.post(form["action"], data=xss_data, headers=HEADERS, timeout=5)
                else:
                    res = requests.get(form["action"], params=xss_data, headers=HEADERS, timeout=5)

                # Check if payload is reflected in the response
                if XSS_PAYLOAD in res.text:
                    results.append({
                        "type": "XSS",
                        "url": form["action"],
                        "payload": XSS_PAYLOAD,
                        "evidence": res.text[:300]  # Show first 300 characters of response
                    })

            except Exception as e:
                print(f"[!] XSS test failed at {form['action']}: {e}")


            # ============ SQLi TESTING ============
            for payload in SQLI_PAYLOADS:
                sqli_data = {name: payload for name in form["inputs"]}

                try:
                    # Send SQLi payload
                    if form["method"] == "post":
                        res = requests.post(form["action"], data=sqli_data, headers=HEADERS, timeout=5)
                    else:
                        res = requests.get(form["action"], params=sqli_data, headers=HEADERS, timeout=5)

                    # Look for reflected payload or SQL error messages
                    if payload in res.text or re.search(r"(sql|mysql|syntax|error|odbc|exception|query)", res.text, re.I):
                        results.append({
                            "type": "SQL Injection",
                            "url": form["action"],
                            "payload": payload,
                            "evidence": res.text[:300]  # Show a part of the response for reference
                        })

                        break  # Stop further SQLi tests for this form if found

                except Exception as e:
                    print(f"[!] SQLi test failed at {form['action']}: {e}")

    except Exception as e:
        print(f"[!] Something went wrong while scanning {url}: {e}")

    return results  # Return final list of vulnerabilities


# ----------------------------------------------------
# üåê FLASK ROUTE TO HANDLE FORM SUBMISSION AND OUTPUT
# ----------------------------------------------------
@app.route("/", methods=["GET", "POST"])
def index():
    results = []  # Default: no results yet

    if request.method == "POST":
        target_url = request.form.get("url")  # Get URL from input box
        if target_url:
            results = test_vulnerabilities(target_url)  # Start scanning

    return render_template_string(TEMPLATE, results=results)


# ----------------------------------------------------
# ‚ñ∂Ô∏è RUN THE FLASK APP ON LOCALHOST
# ----------------------------------------------------
if __name__ == "__main__":
    app.run(debug=False)  # debug=False = production-like mode
